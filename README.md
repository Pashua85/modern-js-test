# Modern JS Test Task

## Требования

- Node.js v20.19.0
- Yarn (berry/modern-js)

## Быстрый старт

```bash
yarn setup
yarn dev
```

## Описание.

Дано приложение, состоящие из хоста и микрофронтенда. Реализовано с помощью `Modern.js` + `ssr` + `Module Federation`.
На странице пользователя выводятся данные о пользователе.
Данные о пользователе на странице выводятся в нескольких местах (панель дополнительной информации открывается по свичу).
Выводится английский или русский вариант имени:

- http://localhost:8080/users/1   - выводится английский вариант имени по умолчанию
- http://localhost:8080/users/1?locale=en - выводится английский вариант имени
- http://localhost:8080/users/1?locale=ru - выводится русский вариант имени

На странице профиля замечено некорректное поведение. Как можно воcпроизвести:

- запустить приложение, открыть главную страницу http://localhost:8080
- перейти на англоязычный вариант профиля 
- скопировать роут, ввести в соседней вкладке, перед этим изменив в ручную locale на 'ru' - отобразится русский вариант имени - как и должно
- если снова вернуться на предыдущую вкладку и ее перезагрузить, то там сначала отобразится русскоязычное имя несмотря на locale в роуте, а затем будет warning в консоли:


![Hydration warning](images/WARNING_SCREEN.png)

## Задача.

- Найти и объяснить причину бага.
- Придумать способ устранения бага и его реализовать. 

При этом должно сохраниться функциональное требование к странице профиля:

- в рамках одного роута (то есть при одно id пользователя и локале) должна сохраняться 
оптимизация запросов о данных пользователя (кеширование) - то есть если мы уже получили данные для верхнего компонента, то при открытии дополнительной панели данные не должны по новой подгружаться.

## Объяснение бага.

Изначально UserClient был один на весь Node-процесс и кешировал значения в Map, где ключом служил только userId. То есть locale в ключ не входила, поэтому первый запрос /users/1?locale=ru складывал в кеш «Алиса», и следующий запрос /users/1?locale=en видел ту же запись и возвращал русский вариант, хотя должен был взять английский. Поскольку синглтон жил между запросами, кеш «протекал» от одного пользователя к другому, а отсутствие locale в ключе делало утечку очевидной.

## Вариант решения через Фабрику

1. **Фабрика вместо синглтона.** `remote/src/lib/userClient.ts` экспортирует `createUserClient`, а `remote/UserClientProvider` создаёт экземпляр на каждый SSR/CSR‑рендер и кладёт его в контекст. Кеш живёт только в рамках запроса.
2. **Кеш и Suspense внутри клиента.** `UserClient` хранит и значения, и промисы (`pending`). `readUserName` просто читает кеш через `peekUserName` или бросает `getUserName(client, ...)`, поэтому повторные рендеры не уходят в сеть.
3. **Host оборачивает remote‑виджеты провайдером.** На странице `host/src/routes/users/[id]/page.tsx` и основной блок, и дополнительная панель находятся внутри `remote/UserClientProvider`, поэтому делят один request-scoped клиент, а соседние HTTP‑запросы получают свежие инстансы.